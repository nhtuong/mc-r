{
    "contents" : "#Package: mc\n#Title: Commonly used functions for Nutriomics Team (INSERM U872)\n#Version: 1.0\n#Date: 2013-11-26\n#Author: Aurelie Cotillard, Edi Prifti, Hoai Tuong Nguyen (A-Z order)\n#Maintainer: Hoai Tuong Nguyen <hoai-tuong.nguyen@inserm.fr>\n#Description: Statistical and datamining tools for omics data analysis.\n#License: PPL\n\n#Examples\nif(FALSE){\n  \n  #load \"mc\" package\n  library(mc)\n  \n  #load \"xtable\" package, automatically install the package if it does not exist, then load it\n  library.mc(\"xtable\")\n  \n  #read a large file\n  data<-read.table.mc(\"http://statistics.vn/data/doesgenes.txt\",header=T,sep=\";\",nrow=1000)\n  \n  #get statistics on the columns of a matrix/data.frame and export the results as table to Latex codes\n  attach(mtcars)\n  sum<-summary.numeric.mc(mtcars,latex=T)\n  \n  #test the normality of a (list of) numeric variable(s)\n  attach(mtcars)\n  normality.mc(mtcars)\n  \n  #get class type for a (list of) variable(s)\n  attach(mtcars)\n  class.mc(mtcars)\n  \n  #plot the correlation, add lowess line to plot and write the output\n  output.dir=\"../results\"\n  attach(swiss)\n  reg.plot.mc(Fertility,Agriculture,\n              type=\"lowess\",\n              pch=ifelse(swiss$Examination>10, 0, 1),         \n              subjects=as.vector(rownames(swiss)),\n              title=\"CORRELATION - LOWESS\",\n              xlab=\"Fertility\",ylab=\"Agriculture\",\n              legend.topright=list(title=\"SHAPE\",pch=c(1,0),label=c(\"Examination>10\",\"Examination<=10\"),\n                                   col=c(\"black\",\"black\")),\n              imgfile=sprintf(\"%s/lw_swiss-Fertility-Agriculture.pdf\",output.dir),\n              pointsfile=sprintf(\"%s/lw_swiss-Fertility-Agriculture.csv\",output.dir))  \n  \n  #draw a boxplot for two classes, add results of t-test to plot, write the output\n  output.dir=\"../results\"\n  attach(lung)\n  pdf(sprintf(\"%s/lung_factors_by_sex_boxplot.pdf\",output.dir))\n  outfile<-sprintf(\"%s/lung_factors_by_sex_t-test.csv\",output.dir)\n  par(mfrow = c(4, 4))\n  lapply(c(1:4,6:10),function(x) boxplot.class.mc(data=lung,x,\n                                                  class=lung$sex,\n                                                  xlab=\"Sex (0=Female, 1=Male)\",\n                                                  outfile=outfile))\n  dev.off()\n  \n  \n}\n\n\n\n#'@name check.installed.mc\n#'@aliases check.installed.mc\n#'@export check.installed.mc\n#'@docType methods\n#'@title Checking package installation\n#'@description Check whether a packages is installed\n#'@param pkg name of package\n#'@return A logical value indicating whether the package is installed\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'check.installed.mc(\"xtable\")\n#'@seealso \\code{\\link[utils]{install.packages}}\ncheck.installed.mc<-function(pkg){\n  return(is.element(pkg, installed.packages()[,1]))\n}\n\n\n\n#'@name library.mc\n#'@aliases library.mc\n#'@export library.mc\n#'@docType methods\n#'@title Loading and Listing of Packages\n#'@description On-the-fly load or install a package\n#'@param pkg name of package\n#'@return A list of attached packages\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'check.installed.mc(\"xtable\")\n#'@seealso \\code{\\link[utils]{install.packages}}\nlibrary.mc<-function(pkg,repos=\"cran\"){\n  if(!check.installed.mc(pkg)){\n    \n    if (repos==\"bioc\"){\n      source(\"http://www.bioconductor.org/biocLite.R\")\n      biocLite(pkg)\n    } else if (repos==\"cran\"){\n      install.packages(pkg)\n    } else {\n      install.packages(pkg, repos = repos, type=\"source\")\n    }\n    \n    \n  }\n\n  library(pkg,character.only=TRUE)\n  \n\n}\n\n\n#loading dependencies\nlibrary.mc(\"bnlearn\")\nlibrary.mc(\"FunNet\")\nlibrary.mc(\"zoo\")\nlibrary.mc(\"Hmisc\")\nlibrary.mc(\"quantreg\")\nlibrary.mc(\"gdata\",\"cran\")\nlibrary.mc(\"WriteXLS\",\"cran\")\nlibrary.mc(\"xtable\")\nlibrary.mc(\"samr\",\"bioc\")\nlibrary.mc(\"ggplot2\",\"bioc\")\nlibrary.mc(\"reshape\")\nlibrary.mc(\"scales\")\nlibrary.mc(\"hgu95av2\",\"bioc\")\nlibrary.mc(\"hgu95av2.db\",\"bioc\")\nlibrary.mc(\"illuminaHumanv3.db\",\"bioc\")\nlibrary.mc(\"GO.db\",\"bioc\")\n\n\n#'@name read.table.mc\n#'@aliases read.table.mc\n#'@export read.table.mc\n#'@docType methods\n#'@title Data Input\n#'@description Read a very large data file\n#'@param file the name of the file which the data are to be read from.\n#'@param header a logical value indicating whether the file contains the names of the variables as its first line. If missing, the value is determined from the file format: header is set to TRUE if and only if the first row contains one fewer field than the number of columns.\n#'@param sep  the field separator character. Values on each line of the file are separated by this character. If sep = \"\" (the default for read.table) the separator is 'white space', that is one or more spaces, tabs, newlines or carriage returns. A (character) name of the column in a \\code{\\link[base]{data.frame}} which contains the addresses\n#'@param nrow number of rows\n#'@return A data frame (\\code{\\link[base]{data.frame}}) containing a representation of the data in the file\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'library(mc)\n#'data<-read.table.mc(\"http://statistics.vn/data/doesgenes.txt\",header=T,sep=\";\",nrow=1000)\n#'@seealso \\code{\\link[utils]{read.table}}\nread.table.mc<-function(file,header=FALSE,sep=\"\",nrow=-1){\n  #read 5 first rows to get class names of column\n  tab5rows <- read.table(file, nrows = 5,sep=sep)\n  #get class names\n  classes <- sapply(tab5rows, class)\n  #get data frame with specific parameter\n  tabAll <- read.table(file,  header=header, colClasses=classes,sep=sep,nrows=nrow,comment.char = \"\")\n  return(tabAll)\n}\n\n\n\n#'@name summary.numeric.mc\n#'@aliases summary.numeric.mc\n#'@export summary.numeric.mc\n#'@docType methods\n#'@title Object Summaries\n#'@description Summarize an numeric table, save the output to a table, export the output to Latex code\n#'@param object an object for which a summary is desired.\n#'@param latex a logical value indicating whether output to latex is called\n#'@return Table of of the value returned by summary (and output Latex code if parameter 'latex' is TRUE)\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'data(mtcars)\n#'sum<-summary.numeric.mc(mtcars,latex=T)\n#'@seealso \\code{\\link[base]{summary}}\nsummary.numeric.mc<-function(object,latex=FALSE){\n  #get classes of columns\n  classes<-sapply(1:ncol(object), function(x) class(object[,x]))\n  #get summaries for numeric columns\n  summary.numeric<-sapply(which(classes==\"numeric\"), function(x) as.vector(summary(object[,x]))) \n  #transform summaries into table format\n  if (length(which(is.na(object)))>0){\n    summary.numeric<-sapply(which(classes==\"numeric\"), function(x) as.vector(summary(object[,x]))) \n    tmp <- object.frame()\n    for(i in seq(along=summary.numeric)) for(j in 1:length(summary.numeric[[i]]))\n      tmp[i,j] <- ifelse(is.na(summary.numeric[[i]][j]),\"0\",summary.numeric[[i]][j])\n    summary.numeric<-tmp\n    colnames(summary.numeric)<-c(names(summary(1)),\"NA\")\n    summary.numeric[which(is.na(summary.numeric[,7])),7]<-\"0\"    \n  } else {\n    summary.numeric<-t(data.frame(sapply(which(classes==\"numeric\"), function(x) as.vector(summary(object[,x])))))\n    colnames(summary.numeric)<-names(summary(1))\n  }\n  rownames(summary.numeric)<-colnames(object)[which(classes==\"numeric\")]\n  #export table into Latex code\n  if(latex){\n    print(xtable(summary.numeric))\n  }\n  return(summary.numeric)\n}\n\n\n\n#'@name normality.mc\n#'@aliases normality.mc\n#'@export normality.mc\n#'@docType methods\n#'@title Normality Test\n#'@description Perform a normality test for variables \n#'@param m variable (list, matrix, data frame...)\n#'@param alpha p-value threshold\n#'@return logical value indicating whether variable is normally distributed\n#'@author Hoai Tuong Nguyen\n#'@examples\n#' attach(mtcars)\n#' normality.mc(mtcars)\nnormality.mc<-function(m,alpha=0.05){\n  if (class(m)==\"data.frame\" || class(m)==\"matrix\")\n    return(sapply(1:ncol(m), function(x) shapiro.test(m[,x])$p.value<=alpha))\n  else return(shapiro.test(m)$p.value<=alpha)\n}\n\n\n\n#'@name class.mc\n#'@aliases class.mc\n#'@export class.mc\n#'@docType methods\n#'@title Object Classes\n#'@description Get class of variable\n#'@param variable (list, matrix, data frame...)\n#'@return class of variables or of columns of matrix/data frame\n#'@author Hoai Tuong Nguyen\n#'@examples\n#' attach(mtcars)\n#' class.mc(mtcars)\nclass.mc<-function(m){\n  if (class(m)==\"data.frame\" || class(m)==\"matrix\")\n    return(sapply(1:ncol(m),function(x) class(m[,x])))\n  else return(class(m))\n}\n\n\n#'@name reg.plot.mc\n#'@aliases reg.plot.mc\n#'@export reg.plot.mc\n#'@docType methods\n#'@title X-Y Plotting\n#'@description Plot a pair of variables and add regression line (linear or lowess) to plot\n#'@param x a numeric vector \n#'@param y a numeric vector \n#'@param type type of regression line \n#'@param pch type points\n#'@param subjects list of labels for points\n#'@param title main title of plot\n#'@param xlab a title for the x axis\n#'@param ylab a title for the y axis\n#'@param col list of colors for points\n#'@param legend.topleft legend at the top-left of plot\n#'@param legend.topright legend at the top-right of plot\n#'@param imgfile image output filename\n#'@param pointsfile points output filename\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'output.dir=\"../results\"\n#'attach(swiss)\n#'reg.plot.mc(Fertility,Agriculture,\n#'            type=\"lowess\",\n#'            pch=ifelse(swiss$Examination>10, 0, 1),         \n#'            subjects=as.vector(rownames(swiss)),\n#'            title=\"CORRELATION - LOWESS\",\n#'            xlab=\"Fertility\",ylab=\"Agriculture\",\n#'            legend.topright=list(title=\"SHAPE\",pch=c(1,0),label=c(\"Examination>10\",\"Examination<=10\"),col=c(\"black\",\"black\")),\n#'            imgfile=sprintf(\"%s/lw_swiss-Fertility-Agriculture.pdf\",output.dir),\n#'            pointsfile=sprintf(\"%s/lw_swiss-Fertility-Agriculture.csv\",output.dir))\nreg.plot.mc<-function(x,y,separator=NULL,type=\"none\",quantile=\"outter\",arrows=0,pch,subjects=NULL,title=\"CORRELATION\",xlab=\"X\",ylab=\"Y\",col,legend.topleft,legend.topright,legend.bottomleft,legend.bottomright,imgfile=NULL,pointsfile=NULL){\n  \n  source(\"http://www.r-statistics.com/wp-content/uploads/2010/04/Quantile.loess_.r.txt\")\n  \n  #correlation\n  r=rcorr(x,y,type=\"pearson\")[[1]][1,2]\n  rho=rcorr(x,y,type=\"spearman\")[[1]][1,2]\n  \n  #output plot\n  if (!missing(imgfile))\n    pdf(file=imgfile)\n  \n  #colors of points\n  if (missing(col))\n    col=rep(\"black\",length(x),)\n  \n  inter=NULL\n  lm=NULL\n  lw=NULL\n  lmlow=NULL\n  lmup=NULL\n  \n  #Regression line\n  if (type==\"lowess\"){\n    if (quantile!=\"inter\"){\n      lw<-lowess(x,y)\n      \n      up<-which(x>lw$x & y>lw$y)\n    } else {\n      lmlow<-Quantile.loess(x, y,the.quant = 0.25)\n      lw<-lowess(x,y)\n      lmup<-Quantile.loess(x, y,the.quant = 0.75)\n      \n      \n      up<-which(x>lw$x & y>lw$y)\n      \n      inter<-which(y>=fitted(lmlow) & y<=fitted(lmup))\n      \n    }\n  } else if (type==\"lm\") {\n    if (quantile!=\"inter\"){\n      if (is.null(separator)){\n        lm<-lm(y~x)      \n        up<-which(y>fitted(lm))        \n      }else{\n        fitted<-separator[2]*x+separator[1]\n        up<-which(y>fitted)\n      }\n\n    } else {\n      \n      lmlow<-rq(y ~ x, tau = 0.25)\n      lm<-lm(y~x)\n      lmup<-rq(y ~ x, tau = 0.75)\n      \n      \n      \n      up<-which(y>fitted(lm))\n      \n      \n      \n      \n      inter<-which(y>=fitted(lmlow) & y<=fitted(lmup))\n      #inter<-which(residuals(lm(y ~x))>quantile(residuals(lm(y ~x)),c(0.25,0.5,0.75))[1]&residuals(lm(y ~x))<quantile(residuals(lm(y ~x)),c(0.25,0.5,0.75))[3])\n    }\n    \n  }\n  \n  #output points\n  if (type==\"none\")\n    pointsfile=\"none\"\n  if (pointsfile!=\"none\"){\n    p<-rep(\"0\",length(x))\n    p[up]<-\"1\"\n    p[inter]<-\"-\"\n    \n    p.class<-as.vector(p)\n    p.class[which(p.class==\"0\")]<-0\n    p.class[which(p.class==\"1\")]<-1\n    p.class[which(p.class==\"-\")]<-NA\n    p.class<-as.numeric(p.class)\n    \n    col.class<-as.vector(col)\n    col.class[which(col.class==\"blue\")]<-0\n    col.class[which(col.class==\"red\")]<-1\n    col.class[which(col.class==\"yellow\")]<-NA\n    col.class<-as.numeric(col.class)\n    \n    \n  rgc<- cor(p.class,col.class,use=\"complete.obs\")\n\n  \n  #main plot\n  plot(x,y,pch=pch,main=sprintf(\"%s\\n%s vs %s \\nr.idx=%0.4f; rho.idx=%0.4f; r.gc=%0.4f\",title,ylab,xlab,r,rho,rgc),xlab=xlab,ylab=ylab,col=col,cex=0.4)\n  \n  if (type==\"lm\" & !is.null(lmlow))\n    abline(lmlow,col=\"blue\",lty = 2)\n  \n  if (type==\"lm\" & !is.null(lmup))\n    abline(lmup,col=\"green\",lty = 2)\n  \n  if (type==\"lowess\" & !is.null(lmlow))\n    points(lmlow$y.loess ~ lmlow$x, type = \"l\", col = \"blue\")\n  \n  if (type==\"lowess\" & !is.null(lmup))\n    points(lmup$y.loess ~ lmup$x, type = \"l\", col = \"green\")\n  \n  if (type==\"lm\"){\n    if (is.null(separator))\n      abline(lm)\n    else abline(separator)\n  }\n    \n  if (type==\"lowess\")\n    lines(lw,col=3)\n  \n  \n  coltxt=rep(\"black\",length(x),)\n  coltxt[inter]<-\"red\"\n  #labels\n  text(x, y, subjects, cex=0.25,pos=1,offset=0.2,col=coltxt)\n  \n  \n  if (arrows>0){\n    nrow<-length(x)/(arrows+1)\n    s<-1:nrow\n    iter<-arrows\n    while (iter>0){\n      #arrows(x[s], y[s], x[s+nrow], y[s+nrow], col= ifelse(y[s]>y[s+nrow],\"blue\",\"red\"),length=0.03)\n      arrows(x[s], y[s], x[s+nrow], y[s+nrow], col= iter+20,length=0.03)\n      s<-s+nrow\n      iter<-iter-1\n    }\n      \n  }\n  \n  \n  #Legend  \n  if (!missing(legend.topleft))\n    legend(\"topleft\", title=legend.topleft$title,pch=legend.topleft$pch, legend = legend.topleft$label, col = legend.topleft$col, cex=0.4)\n  if (!missing(legend.topright))\n    legend(\"topright\", title=legend.topright$title,pch=legend.topright$pch, legend = legend.topright$label, col = legend.topright$col, cex=0.4)\n  if (!missing(legend.bottomleft))\n    legend(\"bottomleft\", title=legend.topleft$title,pch=legend.bottomleft$pch, legend = legend.bottomleft$label, col = legend.bottomleft$col, cex=0.4)\n  if (!missing(legend.bottomright))\n    legend(\"bottomright\", title=legend.bottomright$title,pch=legend.bottomright$pch, legend = legend.bottomright$label, col = legend.bottomright$col, cex=0.4)\n  \n\n    \n    if (!missing(subjects))\n      write.table(rbind(c(\"Name\",xlab,ylab,\"Levels\"),cbind(subjects,x,y,p)),file=pointsfile,col.names=F,row.names=F,sep=\";\",quote=F)\n    else \n      write.table(rbind(c(xlab,ylab,\"Levels\"),cbind(x,y,p)),file=pointsfile,col.names=F,row.names=T,sep=\";\",quote=F)\n  }\n  \n  #end of output plot\n  if (!missing(imgfile))\n    dev.off()\n  \n}\n\n\n\n#'@name reg.plot.mc\n#'@aliases reg.plot.mc\n#'@export reg.plot.mc\n#'@docType methods\n#'@title X-Y Plotting\n#'@description Plot a pair of variables and add regression line (linear or lowess) to plot\n#'@param x a numeric vector \n#'@param y a numeric vector \n#'@param type type of regression line \n#'@param pch type points\n#'@param subjects list of labels for points\n#'@param title main title of plot\n#'@param xlab a title for the x axis\n#'@param ylab a title for the y axis\n#'@param col list of colors for points\n#'@param legend.topleft legend at the top-left of plot\n#'@param legend.topright legend at the top-right of plot\n#'@param imgfile image output filename\n#'@param pointsfile points output filename\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'output.dir=\"../results\"\n#'attach(swiss)\n#'risk.level.mc(Fertility,Agriculture,\n#'            type=\"lowess\",\n#'            pch=ifelse(swiss$Examination>10, 0, 1),         \n#'            subjects=as.vector(rownames(swiss)),\n#'            title=\"CORRELATION - LOWESS\",\n#'            xlab=\"Fertility\",ylab=\"Agriculture\",\n#'            legend.topright=list(title=\"SHAPE\",pch=c(1,0),label=c(\"Examination>10\",\"Examination<=10\"),col=c(\"black\",\"black\")),\n#'            imgfile=sprintf(\"%s/lw_swiss-Fertility-Agriculture.pdf\",output.dir),\n#'            pointsfile=sprintf(\"%s/lw_swiss-Fertility-Agriculture.csv\",output.dir))\nrisk.level.mc<-function(x,y,type=\"lm\",pch,subjects=NULL,title=\"CORRELATION\",xlab=\"X\",ylab=\"Y\",col,legend.topleft,legend.topright,imgfile=NULL,pointsfile=NULL){\n  \n  #correlation\n  r=rcorr(x,y,type=\"pearson\")[[1]][1,2]\n  rho=rcorr(x,y,type=\"spearman\")[[1]][1,2]\n  \n  #output plot\n  if (!missing(imgfile))\n    pdf(file=imgfile)\n  \n  #colors of points\n  if (missing(col))\n    col=rep(\"black\",length(x),)\n  \n  #main plot\n  plot(x,y,pch=pch,main=sprintf(\"%s\\n%s vs %s \\nr=%0.4f; rho=%0.4f\",title,ylab,xlab,r,rho),xlab=xlab,ylab=ylab,col=col)\n  \n  #labels\n  text(x, y, subjects, cex=0.3,pos=1,offset=0.2)\n  \n  inter=NULL\n  \n  #Regression line\n  if (type==\"lowess\"){\n    lw<-lowess(x,y)\n    lines(lw,col=3)\n    up<-which(x>lw$x & y>lw$y)\n  } else if (type==\"lm\") {\n    if (quantile!=\"inter\"){\n      lm<-lm(y~x)\n      abline(lm)\n      up<-which(y>fitted(lm))\n    } else {\n      \n      lmlow<-rq(y ~ x, tau = 0.25)\n      lm<-lm(y~x)\n      lmup<-rq(y ~ x, tau = 0.75)\n      \n      abline(lmlow,col=\"red\",lty = 2)\n      abline(lm)\n      abline(lmup,col=\"green\",lty = 2)\n      up<-which(y>fitted(lm))\n      inter<-which(y>fitted(lmlow) & y<fitted(lmup))\n    }\n    \n  }\n  \n  #Legend  \n  if (!missing(legend.topleft))\n    legend(\"topleft\", title=legend.topleft$title,pch=legend.topleft$pch, legend = legend.topleft$label, col = legend.topleft$col, cex=0.4)\n  if (!missing(legend.topright))\n    legend(\"topright\", title=legend.topright$title,pch=legend.topright$pch, legend = legend.topright$label, col = legend.topright$col, cex=0.4)\n  \n  \n  #output points\n  if (!missing(pointsfile)){\n    p<-rep(\"0\",length(x))\n    p[up]<-\"1\"\n    p[inter]<-\"-\"\n    if (!missing(subjects))\n      write.table(rbind(c(\"Name\",xlab,ylab,\"Levels\"),cbind(subjects,x,y,p)),file=pointsfile,col.names=F,row.names=F,sep=\";\",quote=F)\n    else \n      write.table(rbind(c(xlab,ylab,\"Levels\"),cbind(x,y,p)),file=pointsfile,col.names=F,row.names=T,sep=\";\",quote=F)\n  }\n  \n  #end of output plot\n  if (!missing(imgfile))\n    dev.off()\n  \n}\n\n\n#'@name boxplot.class.mc\n#'@aliases boxplot.class.mc\n#'@export boxplot.class.mc\n#'@docType methods\n#'@title Box Plots \n#'@description Draw a boxplot for a column of data frame\n#'@param data a data frame\n#'@param x index of column\n#'@param class vector of classes\n#'@param outfile output filename\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'output.dir=\"../results\"\n#'attach(lung)\n#'pdf(sprintf(\"%s/lung_factors_by_sex_boxplot.pdf\",output.dir))\n#'outfile<-sprintf(\"%s/lung_factors_by_sex_t-test.csv\",output.dir)\n#'par(mfrow = c(4, 4))\n#'lapply(c(1:4,6:10),function(x) boxplot.class.mc(data=lung,x,\n#'                                                class=lung$sex,\n#'                                                xlab=\"Sex (0=Female, 1=Male)\",\n#'                                                outfile=outfile))\n#'dev.off()\nboxplot.class.mc<-function(data,x,type=\"auto\",class,xlab,ylab,outfile=NULL){\n  \n  \n  if(missing(ylab))\n    ylab=names(data)[x]\n  if(missing(xlab))\n    xlab=names(class)\n  nskip1 <-!sum(!is.na(data[,x]))<=3\n  #nskip2 <-!sum(data[1,x]==data[,x]) == nrow(data)\n  print(data[,x])\n  print(nskip1)\n  print(nlevels(as.factor(data[,x])))\n\n  if (!is.na(data[,x]) & nskip1 & (nlevels(as.factor(data[,x]))>1)){\n    \n    boxplot(data[,x]~class,ylab=ylab,xlab=xlab) \n    if(type==\"t\")\n      t.res<-t.test(data[,x]~class,ylab=names(data)[x])\n    if(type==\"mwu\")\n      t.res<-wilcox.test(data[,x]~class,ylab=names(data)[x])\n    if(type==\"auto\")\n      if (shapiro.test(data[,x])$p.value<=0.05)\n        t.res<-t.test(data[,x]~class,ylab=names(data)[x])\n    else t.res<-wilcox.test(data[,x]~class,ylab=names(data)[x])\n    \n    title(main=sprintf(\"t=%0.2f; p=%0.2e\\n%s\",t.res$statistic,t.res$p.value,ifelse(t.res$p.value<=0.001,\"***\",ifelse(t.res$p.value<=0.01 & t.res$p.value>0.001,\"**\",ifelse(t.res$p.value<=0.05 & t.res$p.value>0.01,\"*\",\"\")))),cex=0.5)  \n    \n    out<-cbind(colnames(data)[x],t.res$statistic,t.res$p.value,\n               ifelse(t.res$p.value<=0.001,\"***\",ifelse(t.res$p.value<=0.01 & t.res$p.value>0.001,\"**\",ifelse(t.res$p.value<=0.05 & t.res$p.value>0.01,\"*\",\"\"))),\n               shapiro.test(data[,x])$p.value<=0.05)\n    \n  } else \n    out<-cbind(colnames(data)[x],\"NA\",\"NA\",\"NA\",\"NA\")\n  \n  if(!missing(outfile)){\n    write.table(out,outfile,col.names=F,row.names=F,append=T,quote=F,sep=\";\")\n  }   \n}\n\n\n#'@name yule.Q.mc\n#'@aliases yule.Q.mc\n#'@export yule.Q.mc\n#'@docType methods\n#'@title Correlation between nominal variables \n#'@description A measure of correlation between nominal variables\n#'@param x a nominal vector\n#'@param y a nominal vector\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'yule.Q.mc(c(0,1,0,1,1,1,0),c(0,0,1,1,0,1,0))\nyule.Q.mc=function(x,y){(table(x,y)[1,1]*table(x,y)[2,2]-table(x,y)[1,2]*table(\n  x,y)[2,1])/(table(x,y)[1,1]*table(x,y)[2,2]+table(x,y)[1,2]*table(x,y)[2,1])\n}\n\nlibrary.mc(\"samr\",\"bioc\")\n\n#'@name samt.mc\n#'@aliases samt.mc\n#'@export samt.mc\n#'@docType methods\n#'@title Adapted version of samr \n#'@description An adapted version of samr for gene differtiation analysis\n#'@param df a microarray dataframe \n#'@param label vector of label\n#'@param nperms number of permutations\n#'@param logged2 logical. Expression level has been transformed by logorith base 2\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\nsamt.mc<-function(df,label,nperms=100,logged2=T,type=\"Two class unpaired\",seq=F){\n  if(logged2)\n    df<-log2(df)\n  data<-list(x=df,y=label, geneid=as.character(1:nrow(df)),genenames=rownames(df), logged2=TRUE)\n  if (!seq){\n    if (type==\"Two class unpaired\")\n      samr.obj<-samr(data,  resp.type=type, nperms=nperms,testStatistic=\"wilcoxon\")\n    else samr.obj<-samr(data,  resp.type=type, nperms=nperms)\n  }else {\n    if (type==\"Two class unpaired\")\n      samr.obj<-SAMseq(x=df,y=label,  resp.type=type, nperms=nperms,testStatistic=\"wilcoxon\",fdr.output = 0.20)\n    else samr.obj<-SAMseq(x=df,y=label,  resp.type=type, nperms=nperms,fdr.output = 0.20)\n  }\n  \n  delta.table <- samr.compute.delta.table(samr.obj)\n  delta<-0.45\n  siggenes.table<-samr.compute.siggenes.table(samr.obj,delta, data, delta.table)\n  \n  pv=samr.pvalues.from.perms(samr.obj$tt, samr.obj$ttstar)\n  return(list(probeID=rbind(siggenes.table$genes.up,siggenes.table$genes.lo)[,2],\n              UpLow=c(rep(\"UP\",siggenes.table$ngenes.up),rep(\"LOW\",siggenes.table$ngenes.lo)),\n              Stat=rbind(siggenes.table$genes.up,siggenes.table$genes.lo)[,4],\n              RawpValue=pv[rbind(siggenes.table$genes.up,siggenes.table$genes.lo)[,2]],\n              FoldChange=rbind(siggenes.table$genes.up,siggenes.table$genes.lo)[,7],\n              FDR=rbind(siggenes.table$genes.up,siggenes.table$genes.lo)[,8],\n              nsiggenes=siggenes.table$ngenes.up+siggenes.table$ngenes.lo))\n}\n\n#'@name samt.opt.mc\n#'@aliases samt.opt.mc\n#'@export samt.opt.mc\n#'@docType methods\n#'@title Optimized version of samr \n#'@description An optimized version of samr for gene differtiation analysis\n#'@param df a microarray dataframe \n#'@param label vector of label\n#'@param nmax.perms number of maximum permutations\n#'@param logged2 logical. Expression level has been transformed by logorith base 2\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\nsamt.opt.mc<-function(df,label,nmax.perms=100, logged2=T,type=\"Two class unpaired\",seq=F){\n  if(logged2)\n    df<-log2(df)\n  \n  bins<-seq(10,nmax.perms,10)\n  \n  out.log<-do.call(rbind,sapply(bins,function(t){\n    samres<-samt.mc(df, label,t,logged2,type,seq=seq)\n    list(c(nperms=t,nsiggenes=samres$nsiggenes,samres=samres))\n  }\n  ))\n  #nperms.opt<-as.numeric(out.log[which(unlist(out.log[,2])==max(unlist(out.log[,2]))),1])\n  \n  #samres.opt<-out.log[which(unlist(out.log[,2])==max(unlist(out.log[,2]))),3:ncol(out.log)]\n  #print(paste(\"Optimal number of permuations:\",nperms.opt))\n  #print(out.log)\n  plot(out.log[,1:2])\n  \n  return(out.log)\n}\n\n\n\n\n#'@name samr.opt.cluster.mc\n#'@aliases samr.opt.cluster.mc\n#'@export samr.opt.cluster.mc\n#'@docType methods\n#'@title Optimized version of samr with clusters\n#'@description An optimized version of samr with cluster for gene differtiation analysis\n#'@param df a microarray dataframe \n#'@param label vector of label\n#'@param nmax.perms number of maximum permutations\n#'@param logged2 logical. Expression level has been transformed by logorith base 2\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\nsamr.opt.cluster.mc<-function(df,class,label=NULL,file,index,cluster,type=\"Two class unpaired\",logged2=T,nmax.perms=200,seq=F){\n  print(cluster)\n  print(is.null(nrow(df)))\n  if (!is.null(nrow(df)))\n    if ( nrow(df)>=10){\n      \n      if (exists(\"class\")&is.null(label)){\n        print(\"OK\")\n        label<-as.vector(class[colnames(df),4])\n        label[label==0]<-2\n      }\n      \n      sig<-samt.opt.mc(df, \n                       label,\n                       nmax.perms=nmax.perms,\n                       logged2=logged2,\n                       type=type,\n                       seq=seq)\n      \n      i.opt<-which.max(unlist(sig[,2]))\n      \n      if (max(unlist(sig[,2]))>0){\n        sig.opt<-sig[i.opt,]\n        res.sig<-data.frame(sig.opt$samres.probeID,\n                            rep(index,length(sig.opt$samres.probeID)),\n                            sig.opt$samres.UpLow,\n                            sig.opt$samres.Stat,\n                            sig.opt$samres.RawpValue,\n                            sig.opt$samres.FoldChange,\n                            sig.opt$samres.FDR)\n        colnames(res.sig)<-c(\"probeID\", \"Index\", \"UpLow\", \"Stat\",    \"RawpValue\",   \"FoldChange\", \"FDR(%)\")\n        write.table(res.sig,file=sprintf(\"%s_%s.csv\",file,cluster),col.names=T,row.names=F,quote=F,sep=\"\\t\")    \n      }\n      return(sig)\n    }\n  \n}\n\n\n\n\n\n\n\n#'@name get.nona.mc\n#'@aliases get.nona.mc\n#'@export get.nona.mc\n#'@docType methods\n#'@title Filtering missing value genes \n#'@description Filtering missing value genes\n#'@param df a microarray dataframe \n#'@param rate percentage of acceptable non-missing values per gene\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\nget.nona.mc<-function(df,rate){\n  index.nona<-apply(df, 1, function(x) sum(is.na(x)))/ncol(df)<=(1 - rate/100)\n  return(df[index.nona,])\n}\n\n\n#'@name addsigText.mc\n#'@aliases addsigText.mc\n#'@export addsigText.mc\n#'@docType methods\n#'@title Adding significant bar\n#'@description Adding a significant bar to the barplot\n#'@param x0,y0   coordinates of points from which to draw\n#'@param x1,y1   coordinates of points to which to draw\n#'@param lab label to be added\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\naddsigText.mc<-function(x0,y0,x1,y1,lab=\"\",offset){\n  arrows(x0=x0, y0=max(y0,y1)+offset, x1 = x1, y1 = max(y0,y1)+offset,code=0)\n  text(x=mean(c(x0,x1)),y=max(y0,y1)+offset,label=lab,po=3,xpd=TRUE) \n  text(x=x0, y=max(y0,y1)+offset,label=\"|\",xpd=TRUE) \n  text(x=x1, y=max(y0,y1)+offset,label=\"|\",xpd=TRUE)\n}\n\n#'@name barplotStar.mc\n#'@aliases barplotStar.mc\n#'@export barplotStar.mc\n#'@docType methods\n#'@title Bar Plots with significant bar \n#'@description Creates a bar plot with vertical or horizontal bars and significant stars.\n#'@param df  matrix of values of columns\n#'@param title title of bar plot\n#'@param col color of two columns\n#'@param xlab  a label for the x axis\n#'@param ylab  a label for the y axis\n#'@param labels series of columns' names\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\nbarplotStar.mc<-function(df,title=\" \",col=c(\"darkblue\",\"red\"),xlab=\"\",ylab=\"\",labels){\n  barX <-barplot(df, \n                 ylim=c(0,max(df)+max(df)/5),\n                 main=title,\n                 xlab=xlab, \n                 ylab=ylab,\n                 col=col, \n                 names.arg=labels,\n                 beside=TRUE)\n  #text(x=barX,y=df,label=df,po=3,xpd=TRUE) \n  sapply(1:ncol(barX), function(x) addsigText.mc(x0=barX[1,x],y0=df[1,x],x1=barX[2,x],y1=df[2,x],lab=\"***\",offset=max(df)/10))\n  \n}\n\n\n#'@name heatmap.mc\n#'@aliases heatmap.mc\n#'@export heatmap.mc\n#'@docType methods\n#'@title Draw a Heat Map \n#'@description Creates a Heat Map from a matrix of continous values\n#'@param df  matrix of values of columns\n#'@param col color of highest value\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\nheatmap.mc<-function(df,col){\n  df.m <- melt(df)\n  colnames(df.m)<-c(\"Name\",\"variable\",\"value\")\n  df.m <- ddply(df.m, .(variable), transform,   rescale = rescale(value))\n  (p <- ggplot(df.m, aes(variable, Name))\n   + geom_tile(aes(fill = rescale), colour = \"white\")\n   + scale_fill_gradient(low = \"white\",  high = col))\n  return(p)\n}\n\n\n\n#'@name FunNet.mc\n#'@aliases FunNet.mc\n#'@export FunNet.mc\n#'@docType methods\n#'@title FunNet adapted version \n#'@description FunNet adapted version with customized output filenames\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'  high.up.frame<-as.data.frame(read.table(sprintf(\"%s/%s.high.up.genes.txt\",output.dir,fileprefix),sep=\"\\t\",header=F))\n#'  high.down.frame<-as.data.frame(read.table(sprintf(\"%s/%s.high.down.genes.txt\",output.dir,fileprefix),sep=\"\\t\",header=F))\n#'\n#'FunNet.mc(org=\"HS\", two.lists=TRUE, up.frame=high.up.frame, down.frame=high.down.frame,\n#'genes.frame=NULL, restrict=TRUE, ref.list=NULL, logged=FALSE,\n#'discriminant=TRUE, go.bp=TRUE, go.cc=TRUE, go.mf=TRUE, kegg=TRUE,\n#'annot.method=\"specificity\", annot.details=TRUE,\n#'direct=FALSE, enriched=TRUE, fdr=NA, build.annot.net=TRUE,\n#'coexp.matrix=NULL, coexp.method=\"spearman\", estimate.th=FALSE,\n#'hard.th=0.8, soft.th=NA, topological = FALSE, keep.sign=FALSE, level=1,\n#'annot.clust.method=\"umilds\", annot.prox.measure=\"dynamical\",\n#'test.recovery=FALSE, test.robust=FALSE, replace.annot=NA,\n#'build.gene.net=TRUE, gene.clust.method=\"hclust\", gene.net.details=TRUE,\n#'gene.clusters=NA, alpha=0.05, RV=0.90, sigma=NA, keep.rdata=FALSE, zip=TRUE,fileprefix=sprintf(\"%s.high.genes\",\"OK\"))\n\nFunNet.mc<-function (wd = \"\", org = \"hsa\", two.lists = TRUE, up.frame = NULL, \n                     down.frame = NULL, genes.frame = NULL, restrict = FALSE, \n                     ref.list = NULL, logged = FALSE, discriminant = FALSE, go.bp = TRUE, \n                     go.cc = TRUE, go.mf = TRUE, kegg = TRUE, annot.method = \"specificity\", \n                     annot.details = TRUE, direct = FALSE, enriched = TRUE, fdr = NA, \n                     build.annot.net = TRUE, coexp.matrix = NULL, coexp.method = \"spearman\", \n                     estimate.th = FALSE, hard.th = NA, soft.th = NA, topological = FALSE, \n                     keep.sign = FALSE, level = NA, annot.clust.method = \"umilds\", \n                     annot.prox.measure = \"unilat.pond.norm.mean\", test.recovery = FALSE, \n                     test.robust = FALSE, replace.annot = NA, random.annot = FALSE, \n                     build.gene.net = FALSE, gene.clust.method = \"hclust\", gene.net.details = FALSE, \n                     gene.clusters = NA, alpha = 0.05, RV = 0.9, sigma = NA, keep.rdata = FALSE, \n                     zip = TRUE,fileprefix) \n{\n  if (org == \"HS\") {\n    org <- \"hsa\"\n  }\n  if (org == \"MM\") {\n    org <- \"mmu\"\n  }\n  if (org == \"RN\") {\n    org <- \"rno\"\n  }\n  if (org == \"SC\") {\n    org <- \"sce\"\n  }\n  parameter.list <- list(analysis.date = date(), package.version = .funnet.version, \n                         org = org, annot.date = annot.date, annot.method = annot.method, \n                         annot.clust.method = annot.clust.method, annot.prox.measure = annot.prox.measure, \n                         direct = direct, enriched = enriched, fdr = fdr, two.lists = two.lists, \n                         restrict = restrict, go.bp = go.bp, go.cc = go.cc, go.mf = go.mf, \n                         kegg = kegg, discriminant = discriminant, logged = logged, \n                         annot.details = annot.details, estimate.th = estimate.th, \n                         hard.th = hard.th, soft.th = soft.th, coexp.method = coexp.method, \n                         topological = topological, keep.sign = keep.sign, build.annot.net = build.annot.net, \n                         level = level, test.recovery = test.recovery, test.robust = test.robust, \n                         replace.annot = replace.annot, random.annot = random.annot, \n                         build.gene.net = build.gene.net, gene.clust.method = gene.clust.method, \n                         gene.clusters = gene.clusters, gene.net.details = gene.net.details, \n                         alpha = alpha, RV = RV, sigma = sigma, keep.rdata = keep.rdata, \n                         zip = zip)\n  .check.parameters(parameter.list, coexp.matrix, up.frame, \n                    down.frame, ref.list, genes.frame)\n  if (discriminant) {\n    two.lists <- TRUE\n    restrict <- TRUE\n  }\n  if (!is.null(up.frame) & !is.null(down.frame) & is.null(genes.frame)) {\n    two.lists <- TRUE\n  }\n  if (!is.null(genes.frame) & (is.null(up.frame) | is.null(down.frame))) {\n    two.lists <- FALSE\n    discriminant <- FALSE\n  }\n  cat(paste(\"\\n\\tFunNet started at: \", date(), sep = \"\"))\n  cat(paste(\"\\n\\t\\tUsing annotations updated on: \", annot.date, \n            sep = \"\"))\n  if (wd != \"\") {\n    setwd(wd)\n  }\n  results.dir <- paste(fileprefix,\"_\", format(Sys.time(), \"%Y_%b_%d_%H-%M-%S\"), \n                       sep = \"\")\n  dir.create(paste(getwd(), \"/\", results.dir, sep = \"\"))\n  dir.create(paste(getwd(), \"/\", results.dir, \"/html\", sep = \"\"))\n  dir.create(paste(getwd(), \"/\", results.dir, \"/images\", sep = \"\"))\n  try(write.table(as.matrix(print(parameter.list)), col.names = F, \n                  file = paste(getwd(), \"/\", results.dir, \"/\", \"parameters_list.txt\", \n                               sep = \"\"), sep = \"\\t\"))\n  wd <- getwd()\n  locus.name <- annot.base[[org]]$locus.name[, 1:2]\n  locus.symbol <- annot.base[[org]]$locus.name[, c(1, 3)]\n  rownames(locus.name) <- locus.name[, 1]\n  rownames(locus.symbol) <- locus.symbol[, 1]\n  if (two.lists) {\n    up.down <- .filter.genes(up.frame = up.frame, down.frame = down.frame, \n                             two.lists = TRUE, locus.name = locus.name, logged = logged)\n    up.frame <- up.down$up.frame\n    down.frame <- up.down$down.frame\n    rm(up.down)\n    if (discriminant) {\n      ref.list <- c(as.character(up.frame[, 1]), as.character(down.frame[,1]))\n    }\n    else if (restrict & !discriminant) {\n      ref.list <- .filter.genes(restrict = TRUE, ref.list = ref.list, \n                                locus.name = locus.name)\n    }\n    else if (!restrict & !discriminant) {\n      ref.list <- NULL\n    }\n  }\n  else {\n    genes.frame <- .filter.genes(genes.frame = genes.frame, \n                                 two.lists = FALSE, locus.name = locus.name)\n    if (restrict) {\n      ref.list <- .filter.genes(restrict = TRUE, ref.list = ref.list, \n                                locus.name = locus.name)\n    }\n    else {\n      ref.list <- NULL\n    }\n  }\n  cat(paste(\"\\n\\tSaving start-up environment... \", format(Sys.time(), \n                                                          \"%X\"), sep = \"\"))\n  save(up.frame, down.frame, ref.list, genes.frame, parameter.list, \n       coexp.matrix, locus.name, file = paste(getwd(), \"/\", \n                                              results.dir, \"/\", \"start-up_environment.RData\", sep = \"\"), \n       compress = T)\n  save(up.frame, down.frame, ref.list, genes.frame, parameter.list, \n       coexp.matrix, locus.name, file = paste(getwd(), \"/\", \n                                              \"start-up_environment.RData\", sep = \"\"), compress = T)\n  if (estimate.th) {\n    datas <- NULL\n    if (!is.null(up.frame) & !is.null(down.frame)) {\n      datas <- rbind(up.frame, down.frame)\n    }\n    if (!is.null(genes.frame) & (is.null(up.frame) | is.null(down.frame))) {\n      datas <- genes.frame\n    }\n    rownames(datas) <- datas[, 1]\n    datas <- datas[, 2:ncol(datas)]\n    cat(\"\\n\\tHard thresholding...\\n\")\n    try(hard.th <- .PickHardThreshold(datExpr1 = t(datas), \n                                      coexp.method = coexp.method))\n    try(write.table(hard.th$tablou, file = paste(getwd(), \n                                                 \"/\", results.dir, \"/\", coexp.method, \"_hard_threshold.txt\", \n                                                 sep = \"\"), append = FALSE, col.names = TRUE, , row.names = F, \n                    sep = \"\\t\"))\n    try(write(paste(\"\\n\\nHard threshold estimate: \", hard.th$estimate, \n                    \"\\n\", sep = \"\"), file = paste(getwd(), \"/\", results.dir, \n                                                  \"/\", coexp.method, \"_hard_threshold.txt\", sep = \"\"), \n              append = TRUE))\n    try(write(paste(\"Do not trust this automated estimation without checking it!\\n\", \n                    \"Do not hesitate to select another threshold depending on the associated connectivity values.\\n\", \n                    \"Then please restart FunNet interaction analysis with your selected threshold.\\n\", \n                    sep = \"\"), file = paste(getwd(), \"/\", results.dir, \n                                            \"/\", coexp.method, \"_hard_threshold.txt\", sep = \"\"), \n              append = TRUE))\n    cat(\"\\n\\tSoft thresholding...\\n\")\n    try(soft.th <- .PickSoftThreshold(datExpr1 = t(datas), \n                                      coexp.method = coexp.method))\n    try(write.table(soft.th$tablou, file = paste(getwd(), \n                                                 \"/\", results.dir, \"/\", coexp.method, \"_soft_threshold.txt\", \n                                                 sep = \"\"), append = FALSE, col.names = TRUE, , row.names = F, \n                    sep = \"\\t\"))\n    try(write(paste(\"\\n\\nSoft threshold estimate: \", soft.th$estimate, \n                    \"\\n\", sep = \"\"), file = paste(getwd(), \"/\", results.dir, \n                                                  \"/\", coexp.method, \"_soft_threshold.txt\", sep = \"\"), \n              append = TRUE))\n    try(write(paste(\"Do not trust this automated estimation without checking it!\\n\", \n                    \"Do not hesitate to select another threshold depending on the associated connectivity values.\\n\", \n                    \"Then please restart FunNet interaction analysis with your selected threshold.\\n\", \n                    sep = \"\"), file = paste(getwd(), \"/\", results.dir, \n                                            \"/\", coexp.method, \"_soft_threshold.txt\", sep = \"\"), \n              append = TRUE))\n    print(\"Estimation of the co-expression threshold finished!\")\n    print(\"Please restart FunNet with your chosen threshold.\")\n    if (!keep.rdata) {\n      try(unlink(paste(getwd(), \"/\", results.dir, \"/\", \n                       list.files(path = paste(getwd(), \"/\", results.dir, \n                                               \"/\", sep = \"\"), pattern = \"[:print:]*.RData\"), \n                       sep = \"\"), recursive = TRUE))\n    }\n    if (zip) {\n      try(unlink(paste(getwd(), \"/\", results.dir, \"/html\", \n                       sep = \"\"), recursive = TRUE))\n      try(unlink(paste(getwd(), \"/\", results.dir, \"/images\", \n                       sep = \"\"), recursive = TRUE))\n      try(system(command = paste(\"zip -r9q \", results.dir, \n                                 \".zip \", \"./\", results.dir, \"/*\", sep = \"\")))\n      try(unlink(paste(getwd(), \"/\", results.dir, sep = \"\"), \n                 recursive = TRUE))\n    }\n    options(show.error.messages = FALSE)\n    stop()\n  }\n  if (is.null(coexp.matrix) & (build.annot.net | build.gene.net)) {\n    cat(paste(\"\\n\\tComputing co-expression matrix... \", format(Sys.time(), \n                                                               \"%X\"), sep = \"\"))\n    datas <- NULL\n    if (!is.null(up.frame) & !is.null(down.frame)) {\n      datas <- rbind(up.frame, down.frame)\n    }\n    if (!is.null(genes.frame) & (is.null(up.frame) | is.null(down.frame))) {\n      datas <- genes.frame\n    }\n    rownames(datas) <- datas[, 1]\n    datas <- datas[, 2:ncol(datas)]\n    \n    if (coexp.method %in% c(\"spearman\", \"pearson\", \"kendall\")) {\n      coexp.matrix <- rcorr(t(datas), type = coexp.method)$r\n      \n    }\n    else if (coexp.method == \"euclid\") {\n      coexp.matrix <- 1 - (as.matrix(dist(datas))/max(dist(datas), \n                                                      na.rm = TRUE))\n    }\n    try(save(coexp.matrix, file = paste(getwd(), \"/\", results.dir, \n                                        \"/\", \"brut_coexp_matrix.RData\", sep = \"\"), compress = T))\n  }\n  if (build.annot.net | build.gene.net) {\n    sign.matrix <- coexp.matrix/abs(coexp.matrix)\n    coexp.matrix <- abs(coexp.matrix)\n    if (annot.clust.method %in% c(\"umilds\", \"spectral\")) {\n      if (!is.na(hard.th)) {\n        coexp.matrix[coexp.matrix >= hard.th] <- 1\n        coexp.matrix[coexp.matrix < hard.th] <- 0\n      }\n      else if (!is.na(soft.th)) {\n        coexp.matrix <- coexp.matrix^soft.th\n      }\n      if (topological) {\n        coexp.matrix <- 1 - .TOMdist(adjmat1 = coexp.matrix)\n      }\n      else if (keep.sign) {\n        coexp.matrix <- coexp.matrix * sign.matrix\n      }\n    }\n    else if (annot.clust.method == \"ucknn\" & !is.na(hard.th)) {\n      coexp.matrix[coexp.matrix < hard.th] <- 0\n    }\n    try(save(coexp.matrix, sign.matrix, parameter.list, file = paste(getwd(), \n                                                                     \"/\", results.dir, \"/\", \"gene_adj_matrix.RData\", sep = \"\")))\n  }\n  if (kegg) {\n    terms.name <- KEGG.terms.name\n    rownames(terms.name) <- terms.name[, 1]\n    file.annot <- annot.base[[org]]$KEGG.file.annot\n    taxoname <- \"KEGG\"\n    if (two.lists) {\n      .main.loop(file.annot = file.annot, taxoname = taxoname, \n                 annot.method = annot.method, terms.name = terms.name, \n                 direct = direct, fdr = fdr, go = FALSE, results.dir = results.dir, \n                 alpha = alpha, locus.name = locus.name, annot.clust.method = annot.clust.method, \n                 up.frame = up.frame, down.frame = down.frame, \n                 restrict = restrict, ref.list = ref.list, annot.details = annot.details, \n                 level = NA, build.annot.net = build.annot.net, \n                 test.recovery = test.recovery, test.robust = test.robust, \n                 replace.annot = replace.annot, locus.symbol = locus.symbol, \n                 annot.prox.measure = annot.prox.measure, coexp.matrix = coexp.matrix, \n                 parameter.list = parameter.list, org = org, gene.net.details = gene.net.details, \n                 RV = RV, sigma = sigma, random.annot = random.annot)\n    }\n    else {\n      .main.loop(file.annot = file.annot, taxoname = taxoname, \n                 annot.method = annot.method, terms.name = terms.name, \n                 direct = direct, fdr = fdr, go = FALSE, results.dir = results.dir, \n                 annot.clust.method = annot.clust.method, alpha = alpha, \n                 locus.name = locus.name, genes.frame = genes.frame, \n                 restrict = restrict, ref.list = ref.list, annot.details = annot.details, \n                 level = NA, build.annot.net = build.annot.net, \n                 test.recovery = test.recovery, test.robust = test.robust, \n                 replace.annot = replace.annot, locus.symbol = locus.symbol, \n                 annot.prox.measure = annot.prox.measure, coexp.matrix = coexp.matrix, \n                 parameter.list = parameter.list, org = org, gene.net.details = gene.net.details, \n                 RV = RV, sigma = sigma, random.annot = random.annot)\n    }\n  }\n  go.name <- c(\"GO Biological Process\", \"GO Cellular Component\", \n               \"GO Molecular Function\")\n  terms.name <- GO.terms.name\n  rownames(terms.name) <- terms.name[, 1]\n  if (go.bp) {\n    file.annot <- annot.base[[org]]$GO.DIR.BP.file.annot\n    taxoname <- go.name[1]\n    if (two.lists == TRUE) {\n      .main.loop(file.annot = file.annot, taxoname = taxoname, \n                 annot.method = annot.method, terms.name = terms.name, \n                 direct = direct, fdr = fdr, go = TRUE, results.dir = results.dir, \n                 alpha = alpha, locus.name = locus.name, annot.clust.method = annot.clust.method, \n                 up.frame = up.frame, down.frame = down.frame, \n                 restrict = restrict, ref.list = ref.list, annot.details = annot.details, \n                 level = level, build.annot.net = build.annot.net, \n                 test.recovery = test.recovery, test.robust = test.robust, \n                 replace.annot = replace.annot, locus.symbol = locus.symbol, \n                 annot.prox.measure = annot.prox.measure, coexp.matrix = coexp.matrix, \n                 parameter.list = parameter.list, org = org, gene.net.details = gene.net.details, \n                 RV = RV, sigma = sigma, random.annot = random.annot)\n    }\n    else {\n      .main.loop(file.annot = file.annot, taxoname = taxoname, \n                 annot.method = annot.method, terms.name = terms.name, \n                 direct = direct, fdr = fdr, go = TRUE, results.dir = results.dir, \n                 annot.clust.method = annot.clust.method, alpha = alpha, \n                 locus.name = locus.name, genes.frame = genes.frame, \n                 restrict = restrict, ref.list = ref.list, annot.details = annot.details, \n                 level = level, build.annot.net = build.annot.net, \n                 test.recovery = test.recovery, test.robust = test.robust, \n                 replace.annot = replace.annot, locus.symbol = locus.symbol, \n                 annot.prox.measure = annot.prox.measure, coexp.matrix = coexp.matrix, \n                 parameter.list = parameter.list, org = org, gene.net.details = gene.net.details, \n                 RV = RV, sigma = sigma, random.annot = random.annot)\n    }\n  }\n  if (go.cc) {\n    file.annot <- annot.base[[org]]$GO.DIR.CC.file.annot\n    taxoname <- go.name[2]\n    if (two.lists == TRUE) {\n      .main.loop(file.annot = file.annot, taxoname = taxoname, \n                 annot.method = annot.method, terms.name = terms.name, \n                 direct = direct, fdr = fdr, go = TRUE, results.dir = results.dir, \n                 alpha = alpha, locus.name = locus.name, annot.clust.method = annot.clust.method, \n                 up.frame = up.frame, down.frame = down.frame, \n                 restrict = restrict, ref.list = ref.list, annot.details = annot.details, \n                 level = level, build.annot.net = build.annot.net, \n                 test.recovery = test.recovery, test.robust = test.robust, \n                 replace.annot = replace.annot, locus.symbol = locus.symbol, \n                 annot.prox.measure = annot.prox.measure, coexp.matrix = coexp.matrix, \n                 parameter.list = parameter.list, org = org, gene.net.details = gene.net.details, \n                 RV = RV, sigma = sigma, random.annot = random.annot)\n    }\n    else {\n      .main.loop(file.annot = file.annot, taxoname = taxoname, \n                 annot.method = annot.method, terms.name = terms.name, \n                 direct = direct, fdr = fdr, go = TRUE, results.dir = results.dir, \n                 annot.clust.method = annot.clust.method, alpha = alpha, \n                 locus.name = locus.name, genes.frame = genes.frame, \n                 restrict = restrict, ref.list = ref.list, annot.details = annot.details, \n                 level = level, build.annot.net = build.annot.net, \n                 test.recovery = test.recovery, test.robust = test.robust, \n                 replace.annot = replace.annot, locus.symbol = locus.symbol, \n                 annot.prox.measure = annot.prox.measure, coexp.matrix = coexp.matrix, \n                 parameter.list = parameter.list, org = org, gene.net.details = gene.net.details, \n                 RV = RV, sigma = sigma, random.annot = random.annot)\n    }\n  }\n  if (go.mf) {\n    file.annot <- annot.base[[org]]$GO.DIR.MF.file.annot\n    taxoname <- go.name[3]\n    if (two.lists == TRUE) {\n      .main.loop(file.annot = file.annot, taxoname = taxoname, \n                 annot.method = annot.method, terms.name = terms.name, \n                 direct = direct, fdr = fdr, go = TRUE, results.dir = results.dir, \n                 alpha = alpha, locus.name = locus.name, annot.clust.method = annot.clust.method, \n                 up.frame = up.frame, down.frame = down.frame, \n                 restrict = restrict, ref.list = ref.list, annot.details = annot.details, \n                 level = level, build.annot.net = build.annot.net, \n                 test.recovery = test.recovery, test.robust = test.robust, \n                 replace.annot = replace.annot, locus.symbol = locus.symbol, \n                 annot.prox.measure = annot.prox.measure, coexp.matrix = coexp.matrix, \n                 parameter.list = parameter.list, org = org, gene.net.details = gene.net.details, \n                 RV = RV, sigma = sigma, random.annot = random.annot)\n    }\n    else {\n      .main.loop(file.annot = file.annot, taxoname = taxoname, \n                 annot.method = annot.method, terms.name = terms.name, \n                 direct = direct, fdr = fdr, go = TRUE, results.dir = results.dir, \n                 annot.clust.method = annot.clust.method, alpha = alpha, \n                 locus.name = locus.name, genes.frame = genes.frame, \n                 restrict = restrict, ref.list = ref.list, annot.details = annot.details, \n                 level = level, build.annot.net = build.annot.net, \n                 test.recovery = test.recovery, test.robust = test.robust, \n                 replace.annot = replace.annot, locus.symbol = locus.symbol, \n                 annot.prox.measure = annot.prox.measure, coexp.matrix = coexp.matrix, \n                 parameter.list = parameter.list, org = org, gene.net.details = gene.net.details, \n                 RV = RV, sigma = sigma, random.annot = random.annot)\n    }\n  }\n  if (build.gene.net & !is.null(coexp.matrix)) {\n    try(clusters <- .build.coexp.net(coexp.matrix = coexp.matrix, \n                                     locus.name = locus.name, locus.symbol = locus.symbol, \n                                     gene.clust.method = gene.clust.method, gene.clusters = gene.clusters))\n    try(save(clusters, parameter.list, file = paste(getwd(), \n                                                    \"/\", results.dir, \"/\", \"co-expression_clusters.RData\", \n                                                    sep = \"\"), compress = T))\n    net.matrix <- coexp.matrix\n    rownames(net.matrix) <- locus.symbol[rownames(net.matrix), \n                                         2]\n    colnames(net.matrix) <- locus.symbol[colnames(net.matrix), \n                                         2]\n    try(.cyto.sym(net.matrix = net.matrix, file.net = paste(getwd(), \n                                                            \"/\", results.dir, \"/\", \"co-expression_net.txt\", sep = \"\"), \n                  diagonal = FALSE, thresh = NULL))\n    rm(net.matrix)\n    try(centrality <- .genes.centrality(adj.matrix = coexp.matrix, \n                                        clusters = clusters, taxoname = taxoname, locus.symbol = locus.symbol, \n                                        results.dir = results.dir, coexp = TRUE))\n    if (two.lists) {\n      up.down <- rbind(matrix(1, nrow(up.frame), 1), matrix(0, \n                                                            nrow(down.frame), 1))\n      rownames(up.down) <- c(as.character(up.frame[, 1]), \n                             as.character(down.frame[, 1]))\n      try(write.table(cbind(rownames(clusters$gene.connect), \n                            as.vector(locus.symbol[rownames(clusters$gene.connect), \n                                                   2]), as.vector(locus.name[rownames(clusters$gene.connect), \n                                                                             2]), up.down, clusters$gene.connect, centrality[rownames(clusters$gene.connect), \n                                                                                                                             ]), file = paste(getwd(), \"/\", results.dir, \n                                                                                                                                              \"/\", \"co-expression_net_info.txt\", sep = \"\"), \n                      sep = \"\\t\", col.names = c(\"geneid\", \"symbol\", \n                                                \"name\", \"up(1)_down(0)\", colnames(clusters$gene.connect), \n                                                colnames(centrality)), row.names = F))\n      try(rm(clusters, up.down, centrality))\n    }\n    else {\n      try(write.table(cbind(rownames(clusters$gene.connect), \n                            as.vector(locus.symbol[rownames(clusters$gene.connect), \n                                                   2]), as.vector(locus.name[rownames(clusters$gene.connect), \n                                                                             2]), clusters$gene.connect, centrality[rownames(clusters$gene.connect), \n                                                                                                                    ]), file = paste(getwd(), \"/\", results.dir, \n                                                                                                                                     \"/\", \"co-expression_net_info.txt\", sep = \"\"), \n                      sep = \"\\t\", col.names = c(\"geneid\", \"symbol\", \n                                                \"name\", colnames(clusters$gene.connect), colnames(centrality)), \n                      row.names = F))\n      try(rm(clusters, centrality))\n    }\n    cat(paste(\"\\n\\tCo-expression net building finished... \", \n              date(), sep = \"\"))\n    rm()\n  }\n  if (!keep.rdata) {\n    try(unlink(paste(getwd(), \"/\", results.dir, \"/\", list.files(path = paste(getwd(), \n                                                                             \"/\", results.dir, \"/\", sep = \"\"), pattern = \"[:print:]*.RData\"), \n                     sep = \"\"), recursive = TRUE))\n  }\n  if (zip) {\n    try(system(command = paste(\"zip -r9q \", results.dir, \n                               \".zip \", \"./\", results.dir, \"/*\", sep = \"\")))\n    try(unlink(paste(getwd(), \"/\", results.dir, sep = \"\"), \n               recursive = TRUE))\n  }\n  cat(paste(\"\\n\\tEnd  of treatment at: \", date(), \"\\n\", sep = \"\"))\n  rm()\n}\n\n\n#'@name signs.mc\n#'@aliases signs.mc\n#'@export signs.mc\n#'@docType methods\n#'@title Get signs of changes \n#'@description Get signs of changes for a variable at two timepoints\n#'@param t0  values of variable at t0\n#'@param tn  values of variable at tn\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\nsigns.mc<-function(t0,tn){\n  delta<-tn-t0\n  delta[delta<0]<-\"-\"\n  delta[delta>0]<-\"+\"\n  delta[delta==0]<-\"=\"\n  return(delta)  \n}\n\n\n#'@name cause.mc\n#'@aliases cause.mc\n#'@export cause.mc\n#'@docType methods\n#'@title Causality analysis\n#'@description Causality analysis\n#'@param x0  values of variable at x0\n#'@param xn  values of variable at xn\n#'@param y0  values of variable at y0\n#'@param yn  values of variable at yn\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\ncause.mc<-function(x0,xn,y0,yn){\n  signs.x<-signs.mc(x0,xn)\n  signs.y<-signs.mc(y0,yn)  \n  signs.sum<-summary(as.factor(paste(signs.x,signs.y,sep=\"\")))\n  max.probs<-signs.sum/length(signs.x)\n  max.probs.names<-names(max.probs)\n  return(list(signs.sum=signs.sum,max.probs=max.probs,max.probs.names=max.probs.names))  \n}\n\n\n\n\n#'@name updateAnnot.mc\n#'@aliases updateAnnot.mc\n#'@export updateAnnot.mc\n#'@docType methods\n#'@title Update Annotation Database\n#'@description Causality analysis\n#'@param dbfile  actual DB\n#'@param record  new record\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\nupdateAnnot.mc<-function(dbfile,record){\n  Annot.DB<-get(load(file=dbfile))\n  colnames(record)<-c(\"PROBEID_ILMN\",\"ENTREZID\",\"SYMBOL\",\"GENENAME\")\n  new.record.idx<-which(!record[,1]%in%as.vector(Annot.DB[,1]))\n  if (length(new.record.idx)>0)\n    Annot.DB<-rbind(Annot.DB,record[new.record.idx,])\n  return(Annot.DB)\n}\n\n\n#'@name bn.bst.mc\n#'@aliases bn.bst.mc\n#'@export bn.bst.mc\n#'@docType methods\n#'@title Learning Bayesian networks with bootstraping\n#'@description Learning Bayesian networks with bootstraping\n#'@param data dataframe\n#'@param n  number of sample\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'bn.bst.mc(asia,100)\nbn.bst.mc<-function(data,n){\n  \n  net.bst<-do.call(rbind,sapply(1:n,function(x){\n    print(paste(\"Learning iteration:\",x))\n    net<-iamb(data[sample(nrow(data),replace=T),]) \n    list(net$arcs)\n  }))\n  \n  #nodes<-nodes(net.bst)\n  nodes<-union(unique(net.bst[,1]),unique(net.bst[,2]))\n  nodes<-nodes[order(nodes)]\n  \n  cooc.mat<-sapply(1:length(nodes), function(i)\n    sapply(1:length(nodes), function(j){\n      noc<-nrow(net.bst[net.bst[,1]==nodes[i]&net.bst[,2]==nodes[j],])\n      list(ifelse(is.null(noc),0,noc))\n    }\n    )\n  )\n  \n  cooc.mat<-t(cooc.mat)\n  rownames(cooc.mat)<-colnames(cooc.mat)<-nodes\n  \n  cooc.mat<-as.numeric.mat.mc(cooc.mat)/n\n  list<-mat2list.mc(cooc.mat)\n  \n  #toplist<-list[list[,3]>0.5,]\n  toplist<-list\n  \n  from<-as.character(toplist[,1])\n  to<-as.character(toplist[,2])\n  weight<-as.numeric(toplist[,3])\n  toplist.df<-data.frame(cbind(from,to,as.numeric(weight)),stringsAsFactors=FALSE)\n  colnames(toplist.df)<-c(\"f\",\"t\",\"weight\")\n  \n  return(toplist.df)\n}\n\n\n#'@name as.numeric.mat.mc\n#'@aliases as.numeric.mat.mc\n#'@export as.numeric.mat.mc\n#'@docType methods\n#'@title Convert matrix to numeric matrix\n#'@description Convert matrix to numeric matrix\n#'@param data dataframe\n#'@param dec  decimal of number\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\nas.numeric.mat.mc<-function(data,dec=\",\"){\n  rn<-rownames(data)\n  cn<-colnames(data)\n  data<-data.frame(sapply(1:ncol(data),function(x) type.convert(as.character(data[,x]),dec=dec)))\n  rownames(data)<-rn\n  colnames(data)<-cn\n  return(data)\n}\n\n\n#'@name mat2list.mc\n#'@aliases mat2list.mc\n#'@export mat2list.mc\n#'@docType methods\n#'@title Convert matrix to list\n#'@description Convert matrix to list\n#'@param data dataframe\n#'@return a list with weight\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\n#'\nmat2list.mc<-function(data,alpha=0){\n  \n  index.mc<-function(k,m){\n    i=(k-1)%%m+1\n    j=(k-1)%/%m+1\n    return(list(i,j))\n  }\n  \n  getWeight.mc<-function(x,data){\n    i=index.mc(x,nrow(data))[[1]]\n    j=index.mc(x,nrow(data))[[2]]\n    w=as.numeric(data[i,j])\n    return(list(i=rownames(data)[i],j=colnames(data)[j],w=as.numeric(data[i,j])))\n  }\n  \n  \n  \n  #return(t(sapply(1:(nrow(data)*ncol(data)),function(x) getWeight.mc(x,data))))\n  res<-t(sapply(which(data>alpha),function(x) getWeight.mc(x,data)))\n  \n  from<-as.character(res[,1])\n  to<-as.character(res[,2])\n  weight<-as.numeric(res[,3])\n  res.df<-cbind(from,to,weight)\n  res.df<-data.frame(res.df,stringsAsFactors=FALSE)\n  colnames(res.df)=c(\"f\",\"t\", \"weight\")\n  \n  \n  \n  return(res.df)\n}\n\n#'@name list2mat.mc\n#'@aliases list2mat.mc\n#'@export list2mat.mc\n#'@docType methods\n#'@title Convert list to matrix\n#'@description Convert list to matrix\n#'@param list dataframe\n#'@return a matrix\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\n#'\nlist2mat.mc<-function(list,nodes=NULL){\n  if (is.null(nodes)){\n    nodes<-union(unique(as.character(list[,1])),unique(as.character(list[,2])))\n    nodes<-nodes[order(nodes)]\n  }\n  cooc.mat<-sapply(1:length(nodes), function(i)\n    sapply(1:length(nodes), function(j){\n      noc<-mean(as.numeric(list[list[,1]==nodes[i]&list[,2]==nodes[j],3]))\n      list(ifelse(is.na(noc),0,noc))\n    }\n    )\n  )\n  cooc.mat<-t(cooc.mat)\n  rownames(cooc.mat)<-colnames(cooc.mat)<-nodes\n  \n  \n  return(cooc.mat)\n}\n\n\n\n\nnormalizeList.mc<-function(list){\n  df<-data.frame(list,stringsAsFactors=FALSE)\n  colnames(df)=c(\"f\",\"t\", \"weight\" ,\"method\" ,\"param\" , \"dbfile\")\n  list<-sqldf('SELECT \"f\",\"t\", AVG(weight) as \"weight\",\"method\" ,\"param\" , \"dbfile\" FROM df GROUP BY \"f\",\"t\",\"method\" ,\"param\" , \"dbfile\" having AVG(weight) >0.5')\n  print(\"after normalized\")\n  print(list[,1:3])\n  return(list)\n}\n\nnormalizeList.simple.mc<-function(list,alpha=0.5){\n  df<-data.frame(list,stringsAsFactors=FALSE)\n  colnames(df)=c(\"f\",\"t\", \"weight\")\n  list<-sqldf(sprintf('SELECT \"f\",\"t\", AVG(weight) as \"weight\" FROM df GROUP BY \"f\",\"t\" having AVG(weight) >%f',alpha))\n  list<-list[order(list[,3],decreasing=TRUE),]\n  return(list)\n}\n\n\n#'@name impute.mc\n#'@aliases impute.mc\n#'@export impute.mc\n#'@docType methods\n#'@title Imputing missing data\n#'@description Imputing missing data\n#'@param data dataframe\n#'@param m  number of imputations\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\nimpute.mc<-function(data,m){\n  library.mc(\"Amelia\",repos=\"http://r.iq.harvard.edu\")\n  idvars<-which(sapply(1:ncol(data),function(x) (sum(is.na(data[,x]))==0 | nlevels(as.factor(data[,x]))==1)))\n  print(idvars)\n  data.imputed<-amelia(data,idvars=idvars,m=m)\n  return(data.imputed$imputations[m])\n}\n\n\n\n#'@aliases getIgraph.mc\n#'@export getIgraph.mc\n#'@docType methods\n#'@title Getting igraph object\n#'@description Getting igraph object\n#'@param nodes list of nodes\n#'@param edges  list of edges\n#'@param ncolors  colors of nodes\n#'@param ecolors  colors of edges\n#'@param eweights  weights of edges\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\ngetIgraph.mc<-function(nodes,edges,ncolors,ecolors,eweights,directed=TRUE,layout=layout.kamada.kawai){\n  library(\"igraph\")\n  g<-graph.data.frame(edges, directed=directed, vertices=cbind(nodes,nodes))  \n  V(g)$label<-as.character(nodes)\n  #if(exists(\"ncolors\"))\n  V(g)$color <- rainbow(length(nodes))[edge.betweenness.community(g)$membership*4]\n  #if(exists(\"ecolors\"))\n  #  E(g)$color <- ecolors\n  #if(exists(\"eweights\"))\n  #  E(g)$weight <-eweights\n  \n  g$layout <- layout \n  \n  #layout.fruchterman.reingold\n  #layout.kamada.kawai\n  #layout.fruchterman.reingold.grid\n  #layout.lgl\n  #layout.graphopt\n  \n  \n  return(g)  \n}\n\n\n#'@name igraph2gephi.mc\n#'@aliases igraph2gephi.mc\n#'@export igraph2gephi.mc\n#'@docType methods\n#'@title Convertin igraph object to Gephi object\n#'@description Convertin igraph object to Gephi object\n#'@param g igraph object\n#'@param filepath  output file\n#'@return Gephi object\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\nigraph2gephi.mc <- function(g, filepath=\"converted_graph.gexf\")\n{\n  require(igraph)\n  require(rgexf)\n  \n  # gexf nodes require two column data frame (id, label)\n  # check if the input vertices has label already present\n  # if not, just have the ids themselves as the label\n  #print(\"OK1\")\n  #if(is.null(V(g)$label))\n  #  V(g)$label <- as.character(V(g))\n  \n  # similarily if edges does not have weight, add default 1 weight\n  if(is.null(E(g)$weight))\n    E(g)$weight <- rep.int(1, ecount(g))\n  \n  nodes <- data.frame(cbind(V(g)$label, V(g)$label),stringsAsFactors=FALSE)\n  edges <- t(Vectorize(get.edge, vectorize.args='id')(g, 1:ecount(g)))\n  #print(\"OK\")\n  # combine all node attributes into a matrix (and take care of & for xml)\n  #vAttrNames <- setdiff(list.vertex.attributes(g), \"label\") \n  nodesAtt <- data.frame(sapply(list.vertex.attributes(g), function(attr) sub(\"&\", \"&#038;\",get.vertex.attribute(g, attr))))\n  #print(\"OK3\")\n  # combine all edge attributes into a matrix (and take care of & for xml)\n  eAttrNames <- setdiff(list.edge.attributes(g), \"weight\") \n  #print(\"OK4\")\n  edgesAtt <- data.frame(sapply(eAttrNames, function(attr) sub(\"&\", \"&#038;\",get.edge.attribute(g, attr))))\n  #print(\"OK5\")\n  gAttrNames <- setdiff(list.graph.attributes(g), \"layout\") \n  # combine all graph attributes into a meta-data\n  graphAtt <- data.frame(sapply(gAttrNames, function(attr) sub(\"&\", \"&#038;\",get.graph.attribute(g, attr))))\n  #print(graphAtt)\n  # generate the gexf object\n  output <- write.gexf(nodes, edges, \n                       edgesWeight=E(g)$weight,\n                       edgesAtt = edgesAtt,\n                       nodesAtt = nodesAtt,\n                       meta=c(list(creator=\"Gopalakrishna Palem\", description=\"igraph -> gexf converted file\", keywords=\"igraph, gexf, R, rgexf\"), graphAtt))\n  \n  #print(output, filepath, replace=T)\n}\n\n\n\n#'@aliases updateKDB.mc\n#'@export updateKDB.mc\n#'@docType methods\n#'@title Updating knowledge database\n#'@description Updating knowledge database\n#'@param arcs list of edges\n#'@param method  method used to get edges\n#'@param param  parameters of method\n#'@param dbfiles  path storing data files\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\nupdateKDB.mc<-function(newKDB.or,nodes=NULL){\n  KDB.mat.or<-getKDB.mat.mc()\n  KDB.or<-mat2list.mc(KDB.mat.or)\n  KDB.mat.or<-as.numeric.mat.mc(list2mat.mc(KDB.or,nodes),\".\")\n  \n  newKDB.mat.or<-as.numeric.mat.mc(list2mat.mc(newKDB.or,nodes),\".\")\n  \n  meanKDB.mat.or<-(KDB.mat.or+newKDB.mat.or)/2\n  save(meanKDB.mat.or,file=sprintf(\"%s/INTEGRATION/KDB.mat.RData\",input.dir)) \n  return(meanKDB.mat.or)\n}\n\n#'@aliases getKDB.mc\n#'@export getKDB.mc\n#'@docType methods\n#'@title Getting knowledge database\n#'@description Getting knowledge database\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\ngetKDB.mc<-function(){\n  KDB<-get(load(file=sprintf(\"%s/INTEGRATION/KDB.RData\",input.dir)))\n}\n\n#'@aliases saveKDB.mc\n#'@export saveKDB.mc\n#'@docType methods\n#'@title Saving knowledge database\n#'@description Getting knowledge database\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\nsaveKDB.mc<-function(){\n  save(KDB,file=sprintf(\"%s/INTEGRATION/KDB.RData\",input.dir))\n}\n\n#'@aliases getKDB.mat.mc\n#'@export getKDB.mat.mc\n#'@docType methods\n#'@title Getting matrix of knowledge database\n#'@description Getting matrix of knowledge database\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\ngetKDB.mat.mc<-function(){\n  return(get(load(file=sprintf(\"%s/INTEGRATION/KDB.mat.RData\",input.dir))))\n}\n\n\n\n\n\n#'@aliases neo4j.query.mc\n#'@export neo4j.query.mc\n#'@docType methods\n#'@title Executing a query of Cipher language\n#'@description Executing a query of Cipher language\n#'@param query\n#'@author Hoai Tuong Nguyen\n#'@examples\n#'TBD\n#' Function for querying Neo4j from within R \n#' from http://stackoverflow.com/questions/11188918/use-neo4j-with-r\n#' \n#' start n=node(*) match n-[r?]->() delete r, n \n#' sudo /etc/init.d/neo4j-service restart \nneo4j.query.mc <- function(querystring) {\n  library('bitops')\n  library('RCurl')\n  #sudo apt-get install libcurl4-openssl-dev\n  library('RJSONIO')  \n  h = basicTextGatherer()\n  curlPerform(url = \"localhost:7474/db/data/ext/CypherPlugin/graphdb/execute_query\", \n              postfields = paste(\"query\", curlEscape(querystring), \n                                 sep = \"=\"), writefunction = h$update, verbose = FALSE)\n  result <- fromJSON(h$value())\n  data <- data.frame(t(sapply(result$data, unlist)))\n  names(data) <- result$columns\n  return(data)\n}\n\n",
    "created" : 1385460311774.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1818195763",
    "id" : "61E29E50",
    "lastKnownWriteTime" : 1385477528,
    "path" : "C:/Users/Bibo/Dropbox/BI_NUTRIOMIQUES/2.SCRIPTS/src/MC-R/mc/R/mcLite.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}